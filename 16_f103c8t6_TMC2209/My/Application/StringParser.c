/*
 * StringParser.c
 *
 *  Created on: 13 окт. 2022 г.
 *      Author: belyaev
 *
 * Исходник взят с сайта  https://chipenable.ru/index.php/programming-avr/192-prostoy-parser-dlya-mikrokontrollera.html
 * Статья "Простой парсер для микроконтроллера", автор Павел Бобков.
 */
//*******************************************************************************************
//*******************************************************************************************

#include "StringParser.h"

//*******************************************************************************************
//*******************************************************************************************
char buf[SIZE_RECEIVE_BUF];
char *argv[AMOUNT_PAR];

static uint8_t argc = 0;
static uint8_t i 	= 0;
static uint8_t flag = 0;
//*******************************************************************************************
//*******************************************************************************************
void PARS_Init(void){

	argc 	= 0;
	argv[0] = buf;
	flag 	= FALSE;
	i 		= 0;
}
//**********************************************************
void PARS_Parser(char sym){

	//---------------------
	if(sym != '\r')
	{
		if(i < SIZE_RECEIVE_BUF - 1)
		{
			if(sym != ' ')
			{
				//---------------------
				if(!argc)
				{
					argv[0] = buf;
					argc++;
				}
				//---------------------
				if(flag)
				{
					if(argc < AMOUNT_PAR)
					{
						argv[argc] = &buf[i];
						argc++;
					}
					flag = FALSE;
				}
				//---------------------
				buf[i] = sym;
				i++;
			}
			else
			{
				//---------------------
				if(!flag)
				{
					buf[i] = 0;
					i++;
					flag = TRUE;
				}
				//---------------------
			}
		}
		buf[i] = 0;
		return;
	}
	//---------------------
	else
	{
		buf[i] = 0;

		if (argc) PARS_Handler(argc, argv);
		else
		{
			//сюда можно что-то добавить
		}

		argc = 0;
		i 	 = 0;
		flag = FALSE;
	}
	//---------------------
}
//**********************************************************
//Сравнение строк
/*
 * Параметры:
 * s1 		  - первая сравниваемая строка
 * s2 		  - первая сравниваемая строка
 *
 * Выход:
 * 0 - если строки неравны
 * количество символов в совпадающих строках - если строки равны
 *
 */
uint32_t PARS_EqualStr(char *s1, char *s2){

	uint32_t i = 0;
	//---------------------
	//Сравниваем и счистаем символы
	while(s1[i] == s2[i] &&
		  s1[i] != '\0'  &&
		  s2[i] != '\0')
	{
		i++;
	}
	if (s1[i] =='\0' && s2[i] == '\0') return i; //TRUE;
	else							   return FALSE;
}
//**********************************************************
//Сравнение строк без завершающего символа
/*
 * Параметры:
 * refS - строка, с которой сравнивают. Оканчивается символо '\0'
 * s 	- строка, которую сравнивают.
 *
 * Выход:
 * 0 - если строки неравны
 * количество символов в совпадающих строках - если строки равны
 *
 */
uint32_t PARS_EqualWitchRefStr(char *refS, char *s){

	volatile uint32_t i = 0;
	//---------------------
	//Сравниваем и счистаем символы
	while(refS[i]   == s[i] &&
		  refS[i]   != '\0' &&
		  refS[i+1] != '\0')
	{
		i++;
	}
	if(refS[i+1] == '\0' && refS[i] == s[i]) return i+1;
											 return 0;
}
//**********************************************************
uint8_t PARS_StrToUchar(char *s){

	uint8_t value = 0;
	//---------------------
	while(*s == '0') s++;
	while(*s)
	{
		value += (*s - 0x30);
		s++;
		if(*s) value *= 10;
	}
	return value;
}
//**********************************************************
uint32_t PARS_StrToU32(char *s){

	uint32_t value = 0;
	//---------------------
	while(*s == '0') s++;
	while(*s != '\0' && *s != '\r')
	{
		value += (*s - 0x30);
		s++;
		if(*s <= '9' && *s >= '0') value *= 10;
	}
	return value;
}
//**********************************************************
int32_t PARS_StrToI32(char *s){

	int32_t value = 0;
	int32_t sign  = 1;
	//---------------------
	while(*s == '0') s++;
	if(*s == '-') //находим знау минус
	{
		sign = -1;
		s++;
	}
	while(*s != '\0' && *s != '\r')
	{
		value += (*s - 0x30);
		s++;
		if(*s <= '9' && *s >= '0') value *= 10;
	}
	return (value * sign);
}
//*******************************************************************************************
//*******************************************************************************************

//**********************************************************


//*******************************************************************************************
//*******************************************************************************************


