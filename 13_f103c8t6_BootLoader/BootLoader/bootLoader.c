/*
 * bootLoader.c
 *
 *  Created on: 10 февр. 2023 г.
 *      Author: belyaev
 */
//*******************************************************************************************
//*******************************************************************************************

#include "bootLoader.h"

//*******************************************************************************************
//*******************************************************************************************
static I2C_IT_t	bootLoaderI2c;


//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
//Обработчик принятых команда
void _bootLoader_CmdParsing(void){

	uint8_t *dataFrame = I2C_IT_GetpRxBuf(&bootLoaderI2c);
	uint8_t *response  = I2C_IT_GetpTxBuf(&bootLoaderI2c);
	uint8_t txSize;
	uint8_t cmd = dataFrame[0];
	//--------------------------
	//Разбор принятой команды
	switch(cmd)
	{
		//-------------------
		//Получает версию и разрешенные команды, поддерживаемые текущей версией загрузчика.
		case(CMD_BOOT_Get):
			cmd = ~cmd;
			if(dataFrame[1] == cmd) response[0] = CMD_BOOT_ACK;
			else					response[0] = CMD_BOOT_NACK;

			txSize = 1;

			LED_PC13_Toggel();
		break;
		//-------------------
		//Получает версию загрузчика.
		case(CMD_BOOT_GetVersion):
			cmd = ~cmd;
			if(dataFrame[1] == cmd) response[0] = CMD_BOOT_ACK;
			else				    response[0] = CMD_BOOT_NACK;

			txSize = 1;

			LED_PC13_Toggel();
		break;
		//-------------------
		//Получает идентификатор чипа
		case(CMD_BOOT_GetID):
			cmd = ~cmd;
			if(dataFrame[1] == cmd) response[0] = CMD_BOOT_ACK;
			else				    response[0] = CMD_BOOT_NACK;

			txSize = 1;

			LED_PC13_Toggel();
		break;
		//-------------------
		default:

		break;
		//-------------------
	}
	//--------------------------
	//Кол-во байтов в ответе(с полями COUNT и CRC).
	I2C_IT_SetTxSize(&bootLoaderI2c, txSize);
}
//************************************************************
static void _bootLoader_TxParsing(void){

}
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
void BOOT_LOADER_I2CInit(void){

	//Инициализация I2C Slave для работы по прерываниям.
	bootLoaderI2c.i2c		= BOOT_I2C;			//используемый порт I2C
	bootLoaderI2c.i2cMode	= I2C_MODE_SLAVE;	//режим SLAVE
	bootLoaderI2c.gpioRemap = I2C_GPIO_NOREMAP;	//нет ремапа ножек порта I2C
	bootLoaderI2c.i2cSpeed  = BOOT_I2C_SPEED;	//скорость работы порта I2C
	bootLoaderI2c.slaveAddr = BOOT_I2C_ADDR;	//адрес устройства на нине I2C

	bootLoaderI2c.rxBufSize = 2;	//Ждем приема 2 байтов
	bootLoaderI2c.txBufSize = I2C_IT_RX_BUF_SIZE_DEFAULT;
	bootLoaderI2c.i2cSlaveRxCpltCallback = _bootLoader_CmdParsing;
	bootLoaderI2c.i2cSlaveTxCpltCallback = _bootLoader_TxParsing;
	I2C_IT_Init(&bootLoaderI2c);
}
//**********************************************************


//**********************************************************


//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
